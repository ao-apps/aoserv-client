    final Object tableListenersLock = new Object() {
        @Override
        public String toString() {
            return "tableListenersLock - "+getTableID();
        }
    };

    /**
     * The list of <code>TableListener</code>s.
     */
    List<TableListenerEntry> tableListeners;

    /**
     * The lock used for cache event handling.
     */
    final Object eventLock=new Object() {
        @Override
        public String toString() {
            return "EventLock - "+getTableID();
        }
    };

    /**
     * The thread that is performing the batched updates.
     * All access should be protected by the eventLock.
     */
    TableEventThread thread;

    protected AOServTable(AOServConnector<?,?> connector, Class<V> clazz) {
        this.connector=connector;
        //this.client=new SimpleAOClient(connector);
        this.clazz=clazz;
    }

    /**
     * Checks if this table has at least one listener.
     */
    final public boolean hasAnyTableListener() {
        synchronized(tableListenersLock) {
            return tableListeners!=null && !tableListeners.isEmpty();
        }
    }

    final public boolean hasTableListener(TableListener listener) {
        synchronized(tableListenersLock) {
            if(tableListeners==null) return false;
            for(TableListenerEntry tableListenerEntry : tableListeners) {
                if(tableListenerEntry.listener==listener) return true;
            }
            return false;
        }
    }

    /**
     * Registers a <code>TableListener</code> to be notified when
     * the cached data for this table expires.  The default of
     * 1000ms of batching is used.
     *
     * @see  #addTableListener(TableListener,long)
     */
    final public void addTableListener(TableListener listener) {
        addTableListener(listener, 1000);
    }

    /**
     * Registers a <code>TableListener</code> to be notified when
     * the cached data for this table expires.  Repitative incoming
     * requests will be batched into fewer events, in increments
     * provided by batchTime.  If batchTime is 0, the event is immediately
     * and always distributed.  Batched events are performed in
     * concurrent Threads, while immediate events are triggered by the
     * central cache invalidation thread.  In other words, don't use
     * a batchTime of zero unless you absolutely need your code to
     * run immediately, because it causes serial processing of the event
     * and may potentially slow down the responsiveness of the server.
     */
    final public void addTableListener(TableListener listener, long batchTime) {
        if(batchTime<0) throw new IllegalArgumentException("batchTime<0: "+batchTime);

        synchronized(tableListenersLock) {
            if(tableListeners==null) tableListeners=new ArrayList<TableListenerEntry>();
            tableListeners.add(new TableListenerEntry(listener, batchTime));
        }
        synchronized(eventLock) {
            if(batchTime>0 && thread==null) thread=new TableEventThread(this);
            // Tell the thread to recalc its stuff
            eventLock.notifyAll();
        }

        connector.addingTableListener();
    }

    /**
     * Clears the cache, freeing up memory.  The data will be reloaded upon
     * next use.
     */
    public void clearCache() {
    }

    /*
     * Commented-out because I'm not sure if this handles the references like ao_server.server.farm.name
     *  - Dan 2008-04-18
    final public SchemaColumn[] getDefaultSortSchemaColumns() {
        OrderBy[] orderBys=getDefaultOrderBy();
        if(orderBys==null) return null;
        int len=orderBys.length;
        SchemaTable schemaTable=connector.schemaTables.get(getTableID());
        SchemaColumn[] schemaColumns=new SchemaColumn[len];
        for(int c=0;c<len;c++) {
            String columnName=orderBys[c].getExpression();
            SchemaColumn col=schemaTable.getSchemaColumn(connector, columnName);
            if(col==null) throw new AssertionError("Unable to find SchemaColumn: "+columnName+" on "+schemaTable.getName());
            schemaColumns[c]=col;
        }
        return schemaColumns;
    }*/

    /**
     * Indicates ascending sort.
     */
    public static final boolean ASCENDING=true;

    /**
     * Indicates descending sort.
     */
    public static final boolean DESCENDING=false;

    static class OrderBy {
        final private String expression;
        final private boolean order;
        
        OrderBy(String expression, boolean order) {
            this.expression = expression;
            this.order = order;
        }
        
        /**
         * Gets the column name(s) that is used for sorting, may be a complex expression (currently supports things like ao_server.server.farm.name)
         */
        String getExpression() {
            return expression;
        }
        
        /**
         * Gets the ASCENDING or DESCENDING order.
         */
        boolean getOrder() {
            return order;
        }

        @Override
        public String toString() {
            return expression+(order==ASCENDING ? " ASC" : "DESC");
        }
    }

    /**
     * Gets the default sorting for this table.
     *
     * @return  <code>null</code> if the sorting is performed by the server or the array of column names
     */
    abstract OrderBy[] getDefaultOrderBy();

    final public SQLExpression[] getDefaultOrderBySQLExpressions() throws SQLException, IOException {
        OrderBy[] orderBys=getDefaultOrderBy();
        if(orderBys==null) return null;
        int len=orderBys.length;
        SQLExpression[] exprs=new SQLExpression[len];
        for(int c=0;c<len;c++) exprs[c]=getSQLExpression(orderBys[c].getExpression());
        return exprs;
    }

    /**
     * Sorts the table using the default sort columns and orders.  If no defaults have been provided, then
     * the table is not sorted.
     *
     * @see  #getDefaultSortSQLExpressions()
     */
    protected void sortIfNeeded(List<V> list) throws SQLException, IOException {
        // Get the details for the sorting
        SQLExpression[] sortExpressions=getDefaultOrderBySQLExpressions();
        if(sortExpressions!=null) {
            OrderBy[] orderBys=getDefaultOrderBy();
            boolean[] sortOrders = new boolean[orderBys.length];
            for(int c=0;c<orderBys.length;c++) {
                sortOrders[c] = orderBys[c].getOrder();
            }
            connector.getSchemaTypes().sort(list, sortExpressions, sortOrders);
        }
    }

    /**
     * Gets an approximate number of accessible rows in the database.
     *
     * @see  #size()
     */
    public int getCachedRowCount() throws IOException, SQLException {
        return size();
    }

    final public SQLExpression getSQLExpression(String expr) throws SQLException, IOException {
        int joinPos=expr.indexOf('.');
        if(joinPos==-1) joinPos=expr.length();
        int castPos=expr.indexOf("::");
        if(castPos==-1) castPos=expr.length();
        int columnNameEnd=Math.min(joinPos, castPos);
        String columnName=expr.substring(0, columnNameEnd);
        SchemaColumn lastColumn=getTableSchema().getSchemaColumn(connector, columnName);
        if(lastColumn==null) throw new IllegalArgumentException("Unable to find column: expr="+expr+", column="+getTableName()+'.'+columnName);

        SQLExpression sql=new SQLColumnValue(connector, lastColumn);
        expr=expr.substring(columnNameEnd);

        while(expr.length()>0) {
            if(expr.charAt(0)=='.') {
                List<SchemaForeignKey> keys=lastColumn.getReferences(connector);
                if(keys.size()!=1) throw new IllegalArgumentException("Column "+lastColumn.getSchemaTable(connector).getName()+'.'+lastColumn.column_name+" should reference precisely one column, references "+keys.size());

                joinPos=expr.indexOf('.', 1);
                if(joinPos==-1) joinPos=expr.length();
                castPos=expr.indexOf("::", 1);
                if(castPos==-1) castPos=expr.length();
                int joinNameEnd=Math.min(joinPos, castPos);
                columnName=expr.substring(1, joinNameEnd);
                SchemaColumn keyColumn=keys.get(0).getForeignColumn(connector);
                SchemaTable valueTable=keyColumn.getSchemaTable(connector);
                SchemaColumn valueColumn=valueTable.getSchemaColumn(connector, columnName);
                if(valueColumn==null) throw new IllegalArgumentException("Unable to find column: "+valueTable.getName()+'.'+columnName+" referenced from "+getTableName());

                sql=new SQLColumnJoin(connector, sql, keyColumn, valueColumn);
                expr=expr.substring(joinNameEnd);

                lastColumn=valueColumn;
            } else if(expr.charAt(0)==':' && expr.length()>1 && expr.charAt(1)==':') {
                joinPos=expr.indexOf('.', 2);
                if(joinPos==-1) joinPos=expr.length();
                castPos=expr.indexOf("::", 2);
                if(castPos==-1) castPos=expr.length();
                int typeNameEnd=Math.min(joinPos, castPos);
                String typeName=expr.substring(2, typeNameEnd);
                SchemaType type=connector.getSchemaTypes().get(typeName);
                if(type==null) throw new IllegalArgumentException("Unable to find SchemaType: "+typeName);

                sql=new SQLCast(sql, type);
                expr=expr.substring(typeNameEnd);
            } else throw new IllegalArgumentException("Unable to parse: "+expr);
        }
        return sql;
    }

    /**
     * Gets the rows in a more efficient, indexed manner.
     *
     * @exception UnsupportedOperationException if not supported by the specific table implementation
     */
    final public List<V> getIndexedRows(int col, int value) throws IOException, SQLException {
        return getIndexedRows(col, Integer.valueOf(value));
    }

    /**
     * Gets the rows in a more efficient, indexed manner.  This default implementation simply throws UnsupportedOperationException.
     *
     * @exception UnsupportedOperationException if not supported by the specific table implementation
     */
    public List<V> getIndexedRows(int col, Object value) throws IOException, SQLException {
        throw new UnsupportedOperationException("getIndexedRows now supported by table implementation");
    }

    final public V getUniqueRow(int col, int value) throws IOException, SQLException {
        return getUniqueRowImpl(col, Integer.valueOf(value));
    }

    final public V getUniqueRow(int col, long value) throws IOException, SQLException {
        return getUniqueRowImpl(col, Long.valueOf(value));
    }

    final public V getUniqueRow(int col, Object value) throws IOException, SQLException {
        if(value==null) return null;
        return getUniqueRowImpl(col, value);
    }

    final public V getUniqueRow(int col, short value) throws IOException, SQLException {
        return getUniqueRowImpl(col, Short.valueOf(value));
    }

    protected abstract V getUniqueRowImpl(int col, Object value) throws IOException, SQLException;

    boolean handleCommand(String[] args, InputStream in, TerminalWriter out, TerminalWriter err, boolean isInteractive) throws IOException, SQLException {
        return false;
    }

    /**
     * Checks if the table is loaded.  A table is considered loaded when
     * accessing any part of it will be done entirely locally, avoiding
     * any network traffic.
     */
    public boolean isLoaded() {
        return false;
    }

    /**
     * Prints the contents of this table.
     */
    final public void printTable(AOServConnector<?,?> conn, PrintWriter out, boolean isInteractive) throws IOException, SQLException {
        SchemaTable schemaTable=getTableSchema();
        List<SchemaColumn> cols=schemaTable.getSchemaColumns(conn);
        int numCols=cols.size();
        String[] titles=new String[numCols];
        SchemaType[] types=new SchemaType[numCols];
        boolean[] alignRights=new boolean[numCols];
        for(int c=0;c<numCols;c++) {
            SchemaColumn col=cols.get(c);
            titles[c]=col.getColumnName();
            SchemaType type=types[c]=col.getSchemaType(conn);
            alignRights[c]=type.alignRight();
        }

        Object[] values;
        synchronized(this) {
            List<V> rows=getRows();
            int numRows=rows.size();
            values=new Object[numRows*numCols];
            int pos=0;
            for(int rowIndex=0;rowIndex<numRows;rowIndex++) {
                V row=rows.get(rowIndex);
                for(int colIndex=0;colIndex<numCols;colIndex++) {
                    values[pos++]=types[colIndex].getString(row.getColumn(colIndex));
                }
            }
        }

        SQLUtility.printTable(titles, values, out, isInteractive, alignRights);
    }

    /**
     * Removes a <code>TableListener</code> from the list of
     * objects being notified when the data is updated.
     */
    final public void removeTableListener(TableListener listener) {
        // Get thread reference and release eventLock to avoid deadlock
        Thread myThread;
        synchronized(eventLock) {
            myThread = thread;
        }
        boolean stopThread = false;
        synchronized(tableListenersLock) {
            if(tableListeners!=null) {
                int size=tableListeners.size();
                for(int c=0;c<size;c++) {
                    TableListenerEntry entry=tableListeners.get(c);
                    if(entry.listener==listener) {
                        tableListeners.remove(c);
                        size--;
                        if(entry.delay>0 && myThread!=null) {
                            // If all remaining listeners are immediate (delay 0), kill the thread
                            boolean foundDelayed=false;
                            for(int d=0;d<size;d++) {
                                TableListenerEntry tle=tableListeners.get(d);
                                if(tle.delay>0) {
                                    foundDelayed=true;
                                    break;
                                }
                            }
                            if(!foundDelayed) stopThread = true;
                        }
                        break;
                    }
                }
            }
        }
        synchronized(eventLock) {
            if(stopThread) {
                // The thread will terminate itself once the reference to it is removed
                thread=null;
            }
            // Tell the thread to recalc its stuff
            eventLock.notifyAll();
        }
    }

    void tableUpdated() {
        List<TableListenerEntry> tableListenersSnapshot;
        synchronized(tableListenersLock) {
            tableListenersSnapshot = this.tableListeners==null ? null : new ArrayList<TableListenerEntry>(this.tableListeners);
        }
        if(tableListenersSnapshot!=null) {
            // Notify all immediate listeners
            Iterator<TableListenerEntry> I=tableListenersSnapshot.iterator();
            while(I.hasNext()) {
                final TableListenerEntry entry=I.next();
                if(entry.delay<=0) {
                    // Run in a different thread to avoid deadlock and increase concurrency responding to table update events.
                    AOServConnector.executorService.submit(
                        new Runnable() {
                            public void run() {
                                entry.listener.tableUpdated(AOServTable.this);
                            }
                        }
                    );
                }
            }

            synchronized(eventLock) {
                // Notify the batching thread of the update
                int size=tableListenersSnapshot.size();
                boolean modified = false;
                for(int c=0;c<size;c++) {
                    TableListenerEntry entry=tableListenersSnapshot.get(c);
                    if(entry.delay>0 && entry.delayStart==-1) {
                        entry.delayStart=System.currentTimeMillis();
                        modified = true;
                    }
                }
                if(modified) eventLock.notify();
            }
        }
    }
